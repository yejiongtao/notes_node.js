1. the secret life of objects
	(JavaScript's special ways to deal with objects)
	methods
		there's a special variable, this

	prototypes (similar to inheritance)
		most objects have a prototype (except Object.prototype)
			objects inheritate properties from their prototypes
		the entity behind almost all objects, Object.prototype
			console.log(Object.getPrototypeOf({}) == Object.prototype);	// true
			there are a few methods that come with Object.prototype, such as toString
		other prototypes
			Function.prototype is functions' prototype
			Array.prototype is arrays' prototype
			Function.prototype and Array.prototype's prototype is also Object.prototype
		creating object with a specific prototype
			var dad = { name: 'BA' };
			var son = Object.create(dad);
			console.log(son.name);		// 'BA'

	constructors
		function Rabbit(type) {		// the first letter is capitalized to be distinguished
			this.type = type;	// by default, the this object is returned
		}
		var blackRabbit = new Rabbit("black");	// use new to create objects via a constructor
		Rabbit.prototype.food = "grass";	// get the prototype of the instances created through this constructor
		console.log(blackRabbit.type, 'rabbits eat', blackRabbit.food);

	prototype interference
		enumerable and nonenumerable properties
			all properties we create by simply assigning to them are enumerable
				you can define nonenumerable properties using Object.defineProperty()
			the standard properties in Object.prototype are all nonenumerable
				which will not show in a for/in loop
				but the in operator returns true
		this may be confusing when you use the in operator to determine whether the object contains the property
			to avoid that, use o.hasOwnProperty(name) to decide
	
	prototype-less objects
		var map = Object.create(null);
			// create an object with no prototype, so you donâ€™t have to worry about property interference
			// in this way, all the properties are its own properties
	
	polymorphism
		todo
		


